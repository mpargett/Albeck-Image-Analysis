%IMAN_NAMING
%   Naming conventions for Filters and Fluorophores
%   
%   [fpn, ftn] = iman_naming()
%       To get cell arrays with current naming conventions and regular
%       expression maps.
%   [isvalid] = iman_naming('validate',)

function [fpn, ftn] = iman_naming(varargin)
%Version check provision after name definitions

%Define Fluorophore names, to support consistency
fpn = { 'DAPI',         'dapi'; ...
        'mTagBFP2',     'm?(tag)?bfp2?';...
        'SECFP',        's?e?\s?cfp'; ...
        'mCer',         'm?cer(ulean)?\D*$'; ...
        'mCer3',        'm?cer(ulean)?\s*3\D*$'; ...
        'mTurq2',       'm?turq(uoise)?\s*2?\D*$'; ...
        'TSap',         't?.?sap(phire)?'; ...
        'mNeon',        'm?neon(gre?e?n)?';...
        'YPet',         'y\s?pet'; ...
        'EYFP',         'e?\s?yfp'; ...
        'EGFP',         'e\s?gfp'; ...
%         'Emerald',      'emer(ald)?'; ...
%         'Clover',       'clov(er)?'; ...
        'mVenus',       'm?ven(us)?'; ...
        'mOrange2',     'm?orange2?'; ...
        'mScarlet',     'm?scar(let-?i?)?'; ...
        'mCherry',      'm?che?(rry)?'; ...
        'mKate2',       'm?kate?2?'; ...
        'mCardinal',    'm?card(inal)?'; ...
        'Cy3',          'cy\s*3\D*$'; ...
        'Cy5',          'cy\s*5\D*$'; ...
%         'Cy55',         'cy\s*5\.?5\D*$'; ...
        'NBDG',         'nbdg$'; ...
        'Fluorescein',  'fluorescein|fitc$'; ...
        'Alex405',      'alexa?(fluor)?\s*405\D*$'; ...
        'Alex488',      'alexa?(fluor)?\s*488\D*$'; ...
        'Alex546',      'alexa?(fluor)?\s*546\D*$'; ...
        'Alex555',      'alexa?(fluor)?\s*555\D*$'; ...
        'Alex594',      'alexa?(fluor)?\s*594\D*$'; ...
        'Alex633',      'alexa?(fluor)?\s*633\D*$'; ...
        'Alex647',      'alexa?(fluor)?\s*647\D*$'; ...
        'Alex680',      'alexa?(fluor)?\s*680\D*$'          };

%Define Filter names, to support consistency
ftn = { 'Filter_DAPI',         'dapi'; ...
        'Filter_BFP',          'bfp'; ...
        'Filter_CFP',          '(49001)|cfp'; ...
        'Filter_Sapphire',     'sap(phire)?'; ...
        'Filter_GFP',          'gfp$'; ...
%         'Filter_GFPn',         'gfpn(arrow)?'; ...
        'Filter_YFP',          '(49003)|yfp$'; ...
%         'Filter_YFP2',         'yfp2';...
        'Filter_Orange',       'orange'; ...
        'Filter_Cherry',       '(49005)|che?(rry)?(\s|_|-){0,3}$'; ...
        'Filter_Cherry2',      'che?(rry)?(\s|_|-){0,3}2|tritc'; ... TEMPORARY 'tritc'
        'Filter_Cherry41043',  '(41043)|che?(rry)?(\s|_|-){0,3}4';
        'Filter_Cy5',          'cy\s?5'           };

%Version check and name validation function
if nargin > 0
    if strcmpi(varargin{1},'version'); fpn = 'v1.0'; return; 
    elseif strcmpi(varargin{1},'validate'); 
        %To check names and (optionally) attempt correction
        np = size(fpn,1);        nmi = [fpn; ftn];
        %   Adjust filter name patterns 
        nmi(np+1:end,2) = cellfun(@(x)['filter_?',x], ftn(:,2), 'Un', 0);
        c = assertcell(varargin(2:end)); 
        fpn = cellfun(@(x)any(strcmp(x, nmi(:,1))), c);
        if nargout == 2;    ftn = c;    fpn = double(fpn);
            for s = find(~fpn) %FOR each failed validation
                %   Get indices for matches
                xi = ~cellfun(@isempty, regexpi(c{s}, nmi(:,2))); 
                %Assign output and flag, if unique match is found
                if nnz(xi) == 1; ftn{s} = nmi{xi, 1}; fpn(s) = 2;
                else  %OR declare problems
                    if nnz(xi) == 0;    ftn{s} = 'No match found';
                    elseif nnz(xi) > 1; ftn{s} = 'Too many matches found';
                    end
                end
            end
        end
        
    elseif strcmpi(varargin{1},'match'); 
        %To match correct names, 2nd input must be FPhores, 3rd Filters
        if nargin > 1; c = assertcell(varargin(2));     %Fluorophores
            fpn = cellfun(@(x)fpn{~cellfun(@isempty,regexpi(x, fpn(:,2))),1}, ...
                c, 'Un',0);
        end
        if nargin > 2; c = assertcell(varargin(3));     %Filters
            ftn = cellfun(@(x)ftn{~cellfun(@isempty,regexpi(x, ftn(:,2))),1}, ...
                c, 'Un',0);
        end
    end
end
    
end

%Subfunction to ensure single cell array of names
function c = assertcell(c)
    if ~iscell(c); c = {c}; end
    ci = cellfun(@iscell,c);    %Get nested cells
    if any(ci)  %Fix any nested cells found and check again
        c(~ci) = cellfun(@(x){x}, c(~ci), 'Un',0); %Encapsulate singles
        c = assertcell([c{:}]); %Cat through now complete first cell layer
    end
    %Assert only character strings within each cell
    assert(all(cellfun(@ischar, c)), ['Name inputs must be strings or ',...
        'cell arrays of strings.']);
end


