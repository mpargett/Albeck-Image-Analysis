%IMAN_NAMING
%   Naming conventions for Filters and Fluorophores
%   
%   [fpn, ftn] = iman_naming()
%       To get cell arrays with current naming conventions and regular
%       expression maps.
%   [isvalid] = iman_naming('validate',)
%
%   [isvalid] = iman_naming('match',)

function [fpn, ftn] = iman_naming(varargin)
%Version check provision after name definitions

%Define Fluorophore names, to support consistency
fpn = { 'DAPI',         'dapi'; ...
        'mTagBFP2',     'm?(tag)?bfp2?';...
        'SECFP',        's?e?\s?cfp'; ...
        'mCer',         'm?cer(ulean)?\D*$'; ...
        'mCer3',        'm?cer(ulean)?\s*3\D*$'; ...
        'mTurq2',       'm?turq(uoise)?\s*2?\D*$'; ...
        'TSap',         't?.?sap(phire)?'; ...
        'mNeon',        'm?neon(gre?e?n)?';...
        'YPet',         'y\s?pet'; ...
        'EYFP',         'e?\s?yfp'; ...
        'EGFP',         'e?\s?gfp'; ...
%         'Emerald',      'emer(ald)?'; ...
%         'Clover',       'clov(er)?'; ...
        'mVenus',       'm?ven(us)?'; ...
        'mOrange2',     'm?orange2?'; ...
        'mScarlet',     'm?scar(let-?i?)?'; ...
        'mCherry',      'm?che?(rry)?'; ...
        'mKate2',       'm?kate?2?'; ...
        'mCardinal',    'm?card(inal)?'; ...
        'Cy3',          'cy\s*3\D*$'; ...
        'Cy5',          'cy\s*5\D*$'; ...
%         'Cy55',         'cy\s*5\.?5\D*$'; ...
        'NBDG',         'nbdg$'; ...
        'Fluorescein',  'fluorescein|fitc$'; ...
        'Alex405',      'alexa?(fluor)?\s*405\D*$'; ...
        'Alex488',      'alexa?(fluor)?\s*488\D*$'; ...
        'Alex546',      'alexa?(fluor)?\s*546\D*$'; ...
        'Alex555',      'alexa?(fluor)?\s*555\D*$'; ...
        'Alex594',      'alexa?(fluor)?\s*594\D*$'; ...
        'Alex633',      'alexa?(fluor)?\s*633\D*$'; ...
        'Alex647',      'alexa?(fluor)?\s*647\D*$'; ...
        'Alex680',      'alexa?(fluor)?\s*680\D*$'; ...
        'Ateam_donor',      'ateam_donor$'; ...
        'cp173',      'cp173$'; ...
        'SYTOXr',      'sytoxor$'          };

%Define Filter names, to support consistency
ftn = { 'Filter_DAPI',         'dapi'; ...
        'Filter_BFP',          'bfp'; ...
        'Filter_CFP',          '(49001)|cfp(?!a)'; ...
        'Filter_CFPa',         'cfpa'; ...
        'Filter_Sapphire',     'sap(phire)?'; ...
        'Filter_GFP',          'gfp$'; ...
%         'Filter_GFPn',         'gfpn(arrow)?'; ...
        'Filter_YFP',          '(49003)|yfp$'; ...
%         'Filter_YFP2',         'yfp2';...
        'Filter_Orange',       'orange'; ...
        'Filter_Cherry',       '(49005)|che?(rry)?(\s|_|-){0,3}$'; ...
        'Filter_Cherry2',      'che?(rry)?(\s|_|-){0,3}2|tritc'; ... TEMPORARY 'tritc'
        'Filter_Cherry3',      'che?(rry)?(\s|_|-){0,3}3'; ...
        'Filter_Cherry41043',  '(41043)|che?(rry)?(\s|_|-){0,3}4';
        'Filter_Cy5',          'cy\s?5';...          
        'Filter_PercevalLow',    'PercevalLow';...
        'Filter_PercevalHigh',   'PercevalHigh';...
        'Filter_AteamFluor',    'AteamFluor';...
        'Filter_YCFluor',       'YCFluor';...
        'Filter_FRET_CFPYFP',   'FRET_C2Y'};

%Version check and name validation function
if nargin > 0
    if strcmpi(varargin{1},'version'); fpn = 'v1.0'; return; 
    elseif strcmpi(varargin{1},'validate'); 
        %To check names and (optionally) attempt correction
        np = size(fpn,1);        nmi = [fpn; ftn];
        %   Adjust filter name patterns 
        nmi(np+1:end,2) = cellfun(@(x)['filter_?',x], ftn(:,2), 'Un', 0);
        c = assertcell(varargin(2:end)); 
        fpn = cellfun(@(x)any(strcmp(x, nmi(:,1))), c);
        if nargout == 2;    ftn = c;    fpn = double(fpn);
            for s = find(~fpn) %FOR each failed validation
                %   Get indices for matches
                xi = ~cellfun(@isempty, regexpi(c{s}, nmi(:,2))); 
                %Assign output and flag, if unique match is found
                if nnz(xi) == 1; ftn{s} = nmi{xi, 1}; fpn(s) = 2;
                else  %OR declare problems
                    if nnz(xi) == 0;    ftn{s} = 'No match found';
                    elseif nnz(xi) > 1; ftn{s} = 'Too many matches found';
                    end
                end
            end
        end
        
    elseif strcmpi(varargin{1},'match'); 
        %To match correct names, 2nd input must be FPhores, 3rd Filters
        for sin = 1:nargin-1
            %   Get list to check against
            switch sin; case 1; fin = fpn; case 2; fin = ftn; end
            %   Get inputs to check
            c = assertcell(varargin(sin+1)); 
            %   Check all and get indices of matches
            fidx = cellfun(@(x)find(~cellfun(@isempty,regexpi(x, fin(:,2)))), c, 'un',0);
            %   Identify any failed matches
            fm = cellfun(@isempty,fidx);
            %   Warn about failed matches
            if any(fm);   warning('IMAN:Naming', ...
                    ['No matching name found for: ', csl(c(fm)), '.']);
            end
            %   Assign good matches
            c(~fm) = fin([fidx{:}]);
            %   Set output
            switch sin; case 1; fpn = c; case 2; ftn = c; end
        end
    end
end
    
end

%Subfunction to ensure single cell array of names
function c = assertcell(c)
    if ~iscell(c); c = {c}; end
    ci = cellfun(@iscell,c);    %Get nested cells
    if any(ci)  %Fix any nested cells found and check again
        c(~ci) = cellfun(@(x){x}, c(~ci), 'Un',0); %Encapsulate singles
        c = assertcell([c{:}]); %Cat through now complete first cell layer
    end
    %Assert only character strings within each cell
    assert(all(cellfun(@ischar, c)), ['Name inputs must be strings or ',...
        'cell arrays of strings.']);
end

function lst = csl(in) %Insert commas for a list from a cell
nin = numel(in);    %Get size of input
lst = cat(1, reshape(in,1,nin), [repmat(', ', 1, nin-1), {''}]); %Insert
lst = [lst{:}];     %Arrange into list
end
